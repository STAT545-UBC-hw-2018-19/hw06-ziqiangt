---
title: "hw06"
author: "ziqiangt"
date: "2018/11/05"
output:
  html_document:
    keep_md: true
    toc: yes
---
## Introduction
This is the first assignment of STAT 547M (despite it being named Homework 06).

First, let's load the used data

```r
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(testthat))
suppressPackageStartupMessages(library(stringi))
```


## 1.Character data
### 14.2.5 Exercises
####Q1
In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions? 
Answer: paste() allows us to add an separator between strings while paste0() dose not. Here is an example:

```r
paste("Task", "1", sep = "-")
```

```
## [1] "Task-1"
```

```r
paste0("Task", "1")
```

```
## [1] "Task1"
```

What stringr function are they equivalent to? How do the functions differ in their handling of NA?
Answer: paste() and paste0() equivalent to str_c(). Here is an example:

```r
str_c("Task", "1", sep = "-") 
```

```
## [1] "Task-1"
```

```r
str_c("Task", "1", sep = "")
```

```
## [1] "Task1"
```

How do the functions differ in their handling of NA?
Answer: NA is converted to a string "NA" in paste() and paste0(). However, if NA is one of the input strings for str_c(), the output of str_c() will be NA. Here is an example:

```r
paste("Look ", NA, sep = "")
```

```
## [1] "Look NA"
```

```r
paste0("Look ", NA)
```

```
## [1] "Look NA"
```

```r
str_c("Look ", NA)
```

```
## [1] NA
```

####Q2
In your own words, describe the difference between the sep and collapse arguments to str_c().
Answer:"sep" is used to seperate a vector of strings and keep the vector format. While "collapse" to a vector of strings into a single string. Here is an example:

```r
str_c(c("x", "y", "z"), c("a", "b", "c"), sep = ": ")
```

```
## [1] "x: a" "y: b" "z: c"
```

```r
str_c(c("x", "y", "z"), c("a", "b", "c"), collapse = ":")
```

```
## [1] "xa:yb:zc"
```

####Q3
Use str_length() and str_sub() to extract the middle character from a string. What will you do if the string has an even number of characters?
Answer:First, we need to use str_length to obtain the middle index. Then use str_sub to output the middle character. Here is the example:

```r
odd_string <- "eye"

# A function to find the middle index
find_middle <- function(input) {
  return(str_length(input) / 2 + 1)
}

# Obtain the middle index and output the midelle character
odd_index <- find_middle(odd_string) 
str_sub(odd_string, odd_index, odd_index)
```

```
## [1] "y"
```

What will you do if the string has an even number of characters?
Answer: We need to modify the str_sub. Because there are two middle characters now. Here is an modified example:

```r
even_string <- "eyne"

# A function to find the middle index
find_middle_even <- function(input) {
  return(str_length(input) / 2 + 1 )
}

# Obtain the middle index and output the midelle character
even_index <- find_middle_even(even_string) 
str_sub(even_string, even_index-1, even_index)
```

```
## [1] "yn"
```


####Q4
What does str_wrap() do? When might you want to use it?
Answer: str_wrap() tries to implement the Knuth-Plass paragraph wrapping algorithm. It might be used when we need to sperate a long paragraph into multiple lines. Here is an example:

```r
# a long sentence 
paragraph <- "One or more elements are missing or sketchy. Missed opportunities to complement code and numbers with a figure and interpretation. Technical problem that is relatively easy to fix. It’s hard to find the report in this crazy repo."

# view without wrap
cat(paragraph)
```

```
## One or more elements are missing or sketchy. Missed opportunities to complement code and numbers with a figure and interpretation. Technical problem that is relatively easy to fix. It’s hard to find the report in this crazy repo.
```

```r
# view with wrap
cat(str_wrap(paragraph), sep = "\n")
```

```
## One or more elements are missing or sketchy. Missed opportunities to complement
## code and numbers with a figure and interpretation. Technical problem that is
## relatively easy to fix. It’s hard to find the report in this crazy repo.
```

####Q5
What does str_trim() do? 
Answer: str_trim() removes whitespace from start and end of string. 

```r
# before removing whitespace from start and end of string
spaces_string = "  I am  "
spaces_string
```

```
## [1] "  I am  "
```

```r
# After using str_trim() 
no_spaces_string <- str_trim(spaces_string)
no_spaces_string
```

```
## [1] "I am"
```

What’s the opposite of str_trim()?
Answer: The opposite is str_pad() which is used to add whitespace. Here is an example to combine neighborhood character of letters.

```r
letters %>%
  .[1:10] %>% 
  str_pad(width = 2, side = "right") %>%
  str_c(letters[2:11])
```

```
##  [1] "a b" "b c" "c d" "d e" "e f" "f g" "g h" "h i" "i j" "j k"
```

Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.

```r
vector_to_string <- function(v) {
  if (length(v) == 0){
    return("")
  }
  else if (length(v) == 1){
    return(v)
  }
  else{
    front <- str_c(v[-length(v)], collapse = ", ")
    whole <- str_c(front, v[length(v)], sep = " and ")
    return(whole)
  }
}

#begin to test
vector_to_string(c(""))
```

```
## [1] ""
```

```r
vector_to_string(c("a"))
```

```
## [1] "a"
```

```r
vector_to_string(c("a", "b"))
```

```
## [1] "a and b"
```

```r
vector_to_string(c("a", "b","c"))
```

```
## [1] "a, b and c"
```

### 14.3.1.1 Exercises
#### Q1
Explain why each of these strings don’t match a \: "\", "\\", "\\\"?

symbol | Definition
----------------|------------------
   `\`      |  used as an escape character in regular expressions
   `\\`     | trated as a symbol "\"
   `\\\`    | a back slash + an escape character
   
Here is an example:

```r
test <- "I\\AM"
str_view(test, pattern = "\\\\", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-19137aa36e6144c6883e" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-19137aa36e6144c6883e">{"x":{"html":"<ul>\n  <li>I<span class='match'>\\<\/span>AM<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

####Q2
How would you match the sequence "'\?
Answer: Both ' and \ need to be escaped in regex.

```r
test <- "\"'\\AM"
test
```

```
## [1] "\"'\\AM"
```

```r
str_view(test, pattern = "\"\\'\\\\", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-1f70930eb46e741ab835" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-1f70930eb46e741ab835">{"x":{"html":"<ul>\n  <li><span class='match'>\"'\\<\/span>AM<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

####Q3
What patterns will the regular expression \..\..\.. match? How would you represent it as a string?
Answer: It match ".anycharacter.anycharacter.anycharacter"

```r
test <- "I.A.M.z...xxx"

str_view(test, pattern = "\\..\\..\\..", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-a6b76981538b7f60ed26" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-a6b76981538b7f60ed26">{"x":{"html":"<ul>\n  <li>I<span class='match'>.A.M.z<\/span>...xxx<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

### 14.3.2.1 Exercises
####Q1
How would you match the literal string "$^$"?
Answer: Both $ and ^ need to be escaped in regex.

```r
test <- "$^$, $$sssa"
str_view(test, pattern = "\\$\\^\\ $", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-16281836f5a0979c7798" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-16281836f5a0979c7798">{"x":{"html":"<ul>\n  <li><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

####Q2
Given the corpus of common words in stringr::words, create regular expressions that find all words that:

Start with “y”.

```r
str_view(stringr::words, pattern = "^y", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-681b848c27caab2719e2" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-681b848c27caab2719e2">{"x":{"html":"<ul>\n  <li><span class='match'>y<\/span>ear<\/li>\n  <li><span class='match'>y<\/span>es<\/li>\n  <li><span class='match'>y<\/span>esterday<\/li>\n  <li><span class='match'>y<\/span>et<\/li>\n  <li><span class='match'>y<\/span>ou<\/li>\n  <li><span class='match'>y<\/span>oung<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

End with “x”.

```r
str_view(stringr::words, pattern = "x$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-37a6f150b24d1d935a89" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-37a6f150b24d1d935a89">{"x":{"html":"<ul>\n  <li>bo<span class='match'>x<\/span><\/li>\n  <li>se<span class='match'>x<\/span><\/li>\n  <li>si<span class='match'>x<\/span><\/li>\n  <li>ta<span class='match'>x<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Are exactly three letters long. (Don’t cheat by using str_length()!)

```r
#There are too many matched words
#let's narrow down the search range to the head 20 words
str_view(stringr::words[1:20], pattern = "^.{3}$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-8e03d9a1b225a45b6078" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-8e03d9a1b225a45b6078">{"x":{"html":"<ul>\n  <li><span class='match'>act<\/span><\/li>\n  <li><span class='match'>add<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Have seven letters or more.

```r
#There are too many matched words
#let's narrow down the search range to the head 20 words
str_view(stringr::words[1:20], pattern = "^.{7,}$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-1e4ee29ee68ef429f75b" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-1e4ee29ee68ef429f75b">{"x":{"html":"<ul>\n  <li><span class='match'>absolute<\/span><\/li>\n  <li><span class='match'>account<\/span><\/li>\n  <li><span class='match'>achieve<\/span><\/li>\n  <li><span class='match'>address<\/span><\/li>\n  <li><span class='match'>advertise<\/span><\/li>\n  <li><span class='match'>afternoon<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

###Exercises 14.3.3.1
####Q1
Create regular expressions to find all words that:

Start with a vowel.

```r
str_view(stringr::words, pattern = "^[aeiou]|[AEIOU]", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-50edbdd634548641cd63" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-50edbdd634548641cd63">{"x":{"html":"<ul>\n  <li><span class='match'>a<\/span><\/li>\n  <li><span class='match'>a<\/span>ble<\/li>\n  <li><span class='match'>a<\/span>bout<\/li>\n  <li><span class='match'>a<\/span>bsolute<\/li>\n  <li><span class='match'>a<\/span>ccept<\/li>\n  <li><span class='match'>a<\/span>ccount<\/li>\n  <li><span class='match'>a<\/span>chieve<\/li>\n  <li><span class='match'>a<\/span>cross<\/li>\n  <li><span class='match'>a<\/span>ct<\/li>\n  <li><span class='match'>a<\/span>ctive<\/li>\n  <li><span class='match'>a<\/span>ctual<\/li>\n  <li><span class='match'>a<\/span>dd<\/li>\n  <li><span class='match'>a<\/span>ddress<\/li>\n  <li><span class='match'>a<\/span>dmit<\/li>\n  <li><span class='match'>a<\/span>dvertise<\/li>\n  <li><span class='match'>a<\/span>ffect<\/li>\n  <li><span class='match'>a<\/span>fford<\/li>\n  <li><span class='match'>a<\/span>fter<\/li>\n  <li><span class='match'>a<\/span>fternoon<\/li>\n  <li><span class='match'>a<\/span>gain<\/li>\n  <li><span class='match'>a<\/span>gainst<\/li>\n  <li><span class='match'>a<\/span>ge<\/li>\n  <li><span class='match'>a<\/span>gent<\/li>\n  <li><span class='match'>a<\/span>go<\/li>\n  <li><span class='match'>a<\/span>gree<\/li>\n  <li><span class='match'>a<\/span>ir<\/li>\n  <li><span class='match'>a<\/span>ll<\/li>\n  <li><span class='match'>a<\/span>llow<\/li>\n  <li><span class='match'>a<\/span>lmost<\/li>\n  <li><span class='match'>a<\/span>long<\/li>\n  <li><span class='match'>a<\/span>lready<\/li>\n  <li><span class='match'>a<\/span>lright<\/li>\n  <li><span class='match'>a<\/span>lso<\/li>\n  <li><span class='match'>a<\/span>lthough<\/li>\n  <li><span class='match'>a<\/span>lways<\/li>\n  <li><span class='match'>a<\/span>merica<\/li>\n  <li><span class='match'>a<\/span>mount<\/li>\n  <li><span class='match'>a<\/span>nd<\/li>\n  <li><span class='match'>a<\/span>nother<\/li>\n  <li><span class='match'>a<\/span>nswer<\/li>\n  <li><span class='match'>a<\/span>ny<\/li>\n  <li><span class='match'>a<\/span>part<\/li>\n  <li><span class='match'>a<\/span>pparent<\/li>\n  <li><span class='match'>a<\/span>ppear<\/li>\n  <li><span class='match'>a<\/span>pply<\/li>\n  <li><span class='match'>a<\/span>ppoint<\/li>\n  <li><span class='match'>a<\/span>pproach<\/li>\n  <li><span class='match'>a<\/span>ppropriate<\/li>\n  <li><span class='match'>a<\/span>rea<\/li>\n  <li><span class='match'>a<\/span>rgue<\/li>\n  <li><span class='match'>a<\/span>rm<\/li>\n  <li><span class='match'>a<\/span>round<\/li>\n  <li><span class='match'>a<\/span>rrange<\/li>\n  <li><span class='match'>a<\/span>rt<\/li>\n  <li><span class='match'>a<\/span>s<\/li>\n  <li><span class='match'>a<\/span>sk<\/li>\n  <li><span class='match'>a<\/span>ssociate<\/li>\n  <li><span class='match'>a<\/span>ssume<\/li>\n  <li><span class='match'>a<\/span>t<\/li>\n  <li><span class='match'>a<\/span>ttend<\/li>\n  <li><span class='match'>a<\/span>uthority<\/li>\n  <li><span class='match'>a<\/span>vailable<\/li>\n  <li><span class='match'>a<\/span>ware<\/li>\n  <li><span class='match'>a<\/span>way<\/li>\n  <li><span class='match'>a<\/span>wful<\/li>\n  <li><span class='match'>e<\/span>ach<\/li>\n  <li><span class='match'>e<\/span>arly<\/li>\n  <li><span class='match'>e<\/span>ast<\/li>\n  <li><span class='match'>e<\/span>asy<\/li>\n  <li><span class='match'>e<\/span>at<\/li>\n  <li><span class='match'>e<\/span>conomy<\/li>\n  <li><span class='match'>e<\/span>ducate<\/li>\n  <li><span class='match'>e<\/span>ffect<\/li>\n  <li><span class='match'>e<\/span>gg<\/li>\n  <li><span class='match'>e<\/span>ight<\/li>\n  <li><span class='match'>e<\/span>ither<\/li>\n  <li><span class='match'>e<\/span>lect<\/li>\n  <li><span class='match'>e<\/span>lectric<\/li>\n  <li><span class='match'>e<\/span>leven<\/li>\n  <li><span class='match'>e<\/span>lse<\/li>\n  <li><span class='match'>e<\/span>mploy<\/li>\n  <li><span class='match'>e<\/span>ncourage<\/li>\n  <li><span class='match'>e<\/span>nd<\/li>\n  <li><span class='match'>e<\/span>ngine<\/li>\n  <li><span class='match'>e<\/span>nglish<\/li>\n  <li><span class='match'>e<\/span>njoy<\/li>\n  <li><span class='match'>e<\/span>nough<\/li>\n  <li><span class='match'>e<\/span>nter<\/li>\n  <li><span class='match'>e<\/span>nvironment<\/li>\n  <li><span class='match'>e<\/span>qual<\/li>\n  <li><span class='match'>e<\/span>special<\/li>\n  <li><span class='match'>e<\/span>urope<\/li>\n  <li><span class='match'>e<\/span>ven<\/li>\n  <li><span class='match'>e<\/span>vening<\/li>\n  <li><span class='match'>e<\/span>ver<\/li>\n  <li><span class='match'>e<\/span>very<\/li>\n  <li><span class='match'>e<\/span>vidence<\/li>\n  <li><span class='match'>e<\/span>xact<\/li>\n  <li><span class='match'>e<\/span>xample<\/li>\n  <li><span class='match'>e<\/span>xcept<\/li>\n  <li><span class='match'>e<\/span>xcuse<\/li>\n  <li><span class='match'>e<\/span>xercise<\/li>\n  <li><span class='match'>e<\/span>xist<\/li>\n  <li><span class='match'>e<\/span>xpect<\/li>\n  <li><span class='match'>e<\/span>xpense<\/li>\n  <li><span class='match'>e<\/span>xperience<\/li>\n  <li><span class='match'>e<\/span>xplain<\/li>\n  <li><span class='match'>e<\/span>xpress<\/li>\n  <li><span class='match'>e<\/span>xtra<\/li>\n  <li><span class='match'>e<\/span>ye<\/li>\n  <li><span class='match'>i<\/span>dea<\/li>\n  <li><span class='match'>i<\/span>dentify<\/li>\n  <li><span class='match'>i<\/span>f<\/li>\n  <li><span class='match'>i<\/span>magine<\/li>\n  <li><span class='match'>i<\/span>mportant<\/li>\n  <li><span class='match'>i<\/span>mprove<\/li>\n  <li><span class='match'>i<\/span>n<\/li>\n  <li><span class='match'>i<\/span>nclude<\/li>\n  <li><span class='match'>i<\/span>ncome<\/li>\n  <li><span class='match'>i<\/span>ncrease<\/li>\n  <li><span class='match'>i<\/span>ndeed<\/li>\n  <li><span class='match'>i<\/span>ndividual<\/li>\n  <li><span class='match'>i<\/span>ndustry<\/li>\n  <li><span class='match'>i<\/span>nform<\/li>\n  <li><span class='match'>i<\/span>nside<\/li>\n  <li><span class='match'>i<\/span>nstead<\/li>\n  <li><span class='match'>i<\/span>nsure<\/li>\n  <li><span class='match'>i<\/span>nterest<\/li>\n  <li><span class='match'>i<\/span>nto<\/li>\n  <li><span class='match'>i<\/span>ntroduce<\/li>\n  <li><span class='match'>i<\/span>nvest<\/li>\n  <li><span class='match'>i<\/span>nvolve<\/li>\n  <li><span class='match'>i<\/span>ssue<\/li>\n  <li><span class='match'>i<\/span>t<\/li>\n  <li><span class='match'>i<\/span>tem<\/li>\n  <li><span class='match'>o<\/span>bvious<\/li>\n  <li><span class='match'>o<\/span>ccasion<\/li>\n  <li><span class='match'>o<\/span>dd<\/li>\n  <li><span class='match'>o<\/span>f<\/li>\n  <li><span class='match'>o<\/span>ff<\/li>\n  <li><span class='match'>o<\/span>ffer<\/li>\n  <li><span class='match'>o<\/span>ffice<\/li>\n  <li><span class='match'>o<\/span>ften<\/li>\n  <li><span class='match'>o<\/span>kay<\/li>\n  <li><span class='match'>o<\/span>ld<\/li>\n  <li><span class='match'>o<\/span>n<\/li>\n  <li><span class='match'>o<\/span>nce<\/li>\n  <li><span class='match'>o<\/span>ne<\/li>\n  <li><span class='match'>o<\/span>nly<\/li>\n  <li><span class='match'>o<\/span>pen<\/li>\n  <li><span class='match'>o<\/span>perate<\/li>\n  <li><span class='match'>o<\/span>pportunity<\/li>\n  <li><span class='match'>o<\/span>ppose<\/li>\n  <li><span class='match'>o<\/span>r<\/li>\n  <li><span class='match'>o<\/span>rder<\/li>\n  <li><span class='match'>o<\/span>rganize<\/li>\n  <li><span class='match'>o<\/span>riginal<\/li>\n  <li><span class='match'>o<\/span>ther<\/li>\n  <li><span class='match'>o<\/span>therwise<\/li>\n  <li><span class='match'>o<\/span>ught<\/li>\n  <li><span class='match'>o<\/span>ut<\/li>\n  <li><span class='match'>o<\/span>ver<\/li>\n  <li><span class='match'>o<\/span>wn<\/li>\n  <li><span class='match'>u<\/span>nder<\/li>\n  <li><span class='match'>u<\/span>nderstand<\/li>\n  <li><span class='match'>u<\/span>nion<\/li>\n  <li><span class='match'>u<\/span>nit<\/li>\n  <li><span class='match'>u<\/span>nite<\/li>\n  <li><span class='match'>u<\/span>niversity<\/li>\n  <li><span class='match'>u<\/span>nless<\/li>\n  <li><span class='match'>u<\/span>ntil<\/li>\n  <li><span class='match'>u<\/span>p<\/li>\n  <li><span class='match'>u<\/span>pon<\/li>\n  <li><span class='match'>u<\/span>se<\/li>\n  <li><span class='match'>u<\/span>sual<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

That only contain consonants.

```r
str_view(stringr::words, pattern = "^[^aeiou]{1,}$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-408a1d4407b0bea99654" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-408a1d4407b0bea99654">{"x":{"html":"<ul>\n  <li><span class='match'>by<\/span><\/li>\n  <li><span class='match'>dry<\/span><\/li>\n  <li><span class='match'>fly<\/span><\/li>\n  <li><span class='match'>mrs<\/span><\/li>\n  <li><span class='match'>try<\/span><\/li>\n  <li><span class='match'>why<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

End with ed, but not with eed.

```r
str_view(stringr::words, pattern = "[^e]e{1}d$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-729d37e7c29c4a12d201" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-729d37e7c29c4a12d201">{"x":{"html":"<ul>\n  <li><span class='match'>bed<\/span><\/li>\n  <li>hund<span class='match'>red<\/span><\/li>\n  <li><span class='match'>red<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

End with ing or ise.

```r
str_view(stringr::words, pattern = "ing|ise$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-f7683bdb147962a1a90b" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-f7683bdb147962a1a90b">{"x":{"html":"<ul>\n  <li>advert<span class='match'>ise<\/span><\/li>\n  <li>br<span class='match'>ing<\/span><\/li>\n  <li>dur<span class='match'>ing<\/span><\/li>\n  <li>even<span class='match'>ing<\/span><\/li>\n  <li>exerc<span class='match'>ise<\/span><\/li>\n  <li>k<span class='match'>ing<\/span><\/li>\n  <li>mean<span class='match'>ing<\/span><\/li>\n  <li>morn<span class='match'>ing<\/span><\/li>\n  <li>otherw<span class='match'>ise<\/span><\/li>\n  <li>pract<span class='match'>ise<\/span><\/li>\n  <li>ra<span class='match'>ise<\/span><\/li>\n  <li>real<span class='match'>ise<\/span><\/li>\n  <li>r<span class='match'>ing<\/span><\/li>\n  <li>r<span class='match'>ise<\/span><\/li>\n  <li>s<span class='match'>ing<\/span><\/li>\n  <li>s<span class='match'>ing<\/span>le<\/li>\n  <li>surpr<span class='match'>ise<\/span><\/li>\n  <li>th<span class='match'>ing<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

####Q2
Empirically verify the rule “i before e except after c”.

```r
# Rule “i before e except after c
high_subset <- str_subset(stringr::words, pattern = "[^c]ie|cei")
high_subset %>% knitr::kable()
```



|x          |
|:----------|
|achieve    |
|believe    |
|brief      |
|client     |
|die        |
|experience |
|field      |
|friend     |
|lie        |
|piece      |
|quiet      |
|receive    |
|tie        |
|view       |

```r
# The one which obey the rule
low_subset <- str_subset(stringr::words, pattern = "cie|[^c]ei")
low_subset %>% knitr::kable()
```



|x       |
|:-------|
|science |
|society |
|weigh   |

```r
# Test
if(length(high_subset) > length(low_subset))
  "Rule is correct"
```

```
## [1] "Rule is correct"
```

s “q” always followed by a “u”?

```r
#Find the words q is not followed by u
q_followed_u <- str_subset(stringr::words, pattern = "q[^u]")

#Test
test_that("“q” always followed by a “u”", {
  expect_more_than(1, length(q_followed_u))
})
```

Answer: Test passed

####Q4
Write a regular expression that matches a word if it’s probably written in British English, not American English.
Answer: According to [oxfordinternationalenglish](https://www.oxfordinternationalenglish.com/differences-in-british-and-american-spelling/),British English words ending in ‘our’ usually end in ‘or’ in American English. Here is an example:

```r
# Test vectors
test_words <- c("colour", "flavor", "humour", "labor", "neighbour")

# View results
str_view(test_words, pattern = "our", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-52b14dfcf84c6c4cc3bd" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-52b14dfcf84c6c4cc3bd">{"x":{"html":"<ul>\n  <li>col<span class='match'>our<\/span><\/li>\n  <li>hum<span class='match'>our<\/span><\/li>\n  <li>neighb<span class='match'>our<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

####Q5
Create a regular expression that will match telephone numbers as commonly written in your country.
Answer: In my country, China, the telephone number starts with +86 and have 11 digits (except +86) in total. 

```r
# Test vectors
test_words <- c("+8613777705661", "+16044888876", "+1605888876", "+861377770566")

# View results
str_view(test_words, pattern = "^\\+86[0-9]{11}", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-eed7050a8eabd9f36420" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-eed7050a8eabd9f36420">{"x":{"html":"<ul>\n  <li><span class='match'>+8613777705661<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

###Exercises 14.3.4.1
####Q1
Describe the equivalents of ?, +, * in {m,n} form.
Answer:

symbol | equivalent
----------------|------------------
   `?`      |  {0,1}
   `+`     |  {1,}
   `*`    | {0,}

####Q2
Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.)

symbol | match
----------------|------------------
   `^.*$ `      |  any strings
   `\\{.+\\}`     | {at least one character} for example: {a}, {abd}
   `\d{4}-\d{2}-\d{2}`    | matches in the format dddd-dd-dd, where d is digit. For example, "1111-22-33".
   '\\\\{4}'    | matches four back slashes

####Q3
Create regular expressions to find all words that:
Start with three consonants.

```r
str_view(stringr::words, pattern = "^[^aeoiu]{3,}", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-5398a5c6002de51a011a" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-5398a5c6002de51a011a">{"x":{"html":"<ul>\n  <li><span class='match'>Chr<\/span>ist<\/li>\n  <li><span class='match'>Chr<\/span>istmas<\/li>\n  <li><span class='match'>dry<\/span><\/li>\n  <li><span class='match'>fly<\/span><\/li>\n  <li><span class='match'>mrs<\/span><\/li>\n  <li><span class='match'>sch<\/span>eme<\/li>\n  <li><span class='match'>sch<\/span>ool<\/li>\n  <li><span class='match'>str<\/span>aight<\/li>\n  <li><span class='match'>str<\/span>ategy<\/li>\n  <li><span class='match'>str<\/span>eet<\/li>\n  <li><span class='match'>str<\/span>ike<\/li>\n  <li><span class='match'>str<\/span>ong<\/li>\n  <li><span class='match'>str<\/span>ucture<\/li>\n  <li><span class='match'>syst<\/span>em<\/li>\n  <li><span class='match'>thr<\/span>ee<\/li>\n  <li><span class='match'>thr<\/span>ough<\/li>\n  <li><span class='match'>thr<\/span>ow<\/li>\n  <li><span class='match'>try<\/span><\/li>\n  <li><span class='match'>typ<\/span>e<\/li>\n  <li><span class='match'>why<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Have three or more vowels in a row.

```r
str_view(stringr::words, pattern = "[aeoiu]{3,}", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-ae974c5e07e921d19c5d" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ae974c5e07e921d19c5d">{"x":{"html":"<ul>\n  <li>b<span class='match'>eau<\/span>ty<\/li>\n  <li>obv<span class='match'>iou<\/span>s<\/li>\n  <li>prev<span class='match'>iou<\/span>s<\/li>\n  <li>q<span class='match'>uie<\/span>t<\/li>\n  <li>ser<span class='match'>iou<\/span>s<\/li>\n  <li>var<span class='match'>iou<\/span>s<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Have two or more vowel-consonant pairs in a row.

```r
str_view(stringr::words, pattern = "([aeoiu][^aeoiu]){3,}", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-ce75f9778fce9f71fabc" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ce75f9778fce9f71fabc">{"x":{"html":"<ul>\n  <li><span class='match'>americ<\/span>a<\/li>\n  <li>b<span class='match'>enefit<\/span><\/li>\n  <li>b<span class='match'>usines<\/span>s<\/li>\n  <li>d<span class='match'>efinit<\/span>e<\/li>\n  <li>d<span class='match'>evelop<\/span><\/li>\n  <li>d<span class='match'>ocumen<\/span>t<\/li>\n  <li><span class='match'>econom<\/span>y<\/li>\n  <li><span class='match'>educat<\/span>e<\/li>\n  <li><span class='match'>eleven<\/span><\/li>\n  <li><span class='match'>evenin<\/span>g<\/li>\n  <li><span class='match'>eviden<\/span>ce<\/li>\n  <li>g<span class='match'>eneral<\/span><\/li>\n  <li>h<span class='match'>oliday<\/span><\/li>\n  <li>h<span class='match'>owever<\/span><\/li>\n  <li><span class='match'>imagin<\/span>e<\/li>\n  <li><span class='match'>operat<\/span>e<\/li>\n  <li><span class='match'>original<\/span><\/li>\n  <li>part<span class='match'>icular<\/span><\/li>\n  <li>p<span class='match'>olitic<\/span><\/li>\n  <li>p<span class='match'>ositiv<\/span>e<\/li>\n  <li>s<span class='match'>eparat<\/span>e<\/li>\n  <li>s<span class='match'>imilar<\/span><\/li>\n  <li>sp<span class='match'>ecific<\/span><\/li>\n  <li>t<span class='match'>elevis<\/span>ion<\/li>\n  <li>th<span class='match'>erefor<\/span>e<\/li>\n  <li><span class='match'>univer<\/span>sity<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

####Q4
Solve the beginner regexp crosswords at [this link](https://regexcrossword.com/challenges/beginner).
![](results.png)

###Exercises 14.3.5.1
####Q1
Describe, in words, what these expressions will match:

symbol | match
----------------|------------------
   (.)\1\1      |  match a character followed with \1\1. e.g. "x\1\1"
   "(.)(.)\\2\\1"     | match the two characters followed with and reversal. e.g. "xyyx" 
   `(..)\1`    | match a pair of characters followed with \1. e.g. "ab\1\1"
   "(.).\\1.\\1"    | match in the format "x anycharacter x anycharacter x". e.g. "abaxa"
   "(.)(.)(.).*\\3\\2\\1" | match three characters appears at the beginning, then follows by any characters (0 or more), then the reversal of the begining three characters. For example, "abcxxcba".

####Q2
Construct regular expressions to match words that:
Start and end with the same character.

```r
str_view(stringr::words, pattern = "^(.).*\\1$", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-1ce69385c541def948e4" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-1ce69385c541def948e4">{"x":{"html":"<ul>\n  <li><span class='match'>america<\/span><\/li>\n  <li><span class='match'>area<\/span><\/li>\n  <li><span class='match'>dad<\/span><\/li>\n  <li><span class='match'>dead<\/span><\/li>\n  <li><span class='match'>depend<\/span><\/li>\n  <li><span class='match'>educate<\/span><\/li>\n  <li><span class='match'>else<\/span><\/li>\n  <li><span class='match'>encourage<\/span><\/li>\n  <li><span class='match'>engine<\/span><\/li>\n  <li><span class='match'>europe<\/span><\/li>\n  <li><span class='match'>evidence<\/span><\/li>\n  <li><span class='match'>example<\/span><\/li>\n  <li><span class='match'>excuse<\/span><\/li>\n  <li><span class='match'>exercise<\/span><\/li>\n  <li><span class='match'>expense<\/span><\/li>\n  <li><span class='match'>experience<\/span><\/li>\n  <li><span class='match'>eye<\/span><\/li>\n  <li><span class='match'>health<\/span><\/li>\n  <li><span class='match'>high<\/span><\/li>\n  <li><span class='match'>knock<\/span><\/li>\n  <li><span class='match'>level<\/span><\/li>\n  <li><span class='match'>local<\/span><\/li>\n  <li><span class='match'>nation<\/span><\/li>\n  <li><span class='match'>non<\/span><\/li>\n  <li><span class='match'>rather<\/span><\/li>\n  <li><span class='match'>refer<\/span><\/li>\n  <li><span class='match'>remember<\/span><\/li>\n  <li><span class='match'>serious<\/span><\/li>\n  <li><span class='match'>stairs<\/span><\/li>\n  <li><span class='match'>test<\/span><\/li>\n  <li><span class='match'>tonight<\/span><\/li>\n  <li><span class='match'>transport<\/span><\/li>\n  <li><span class='match'>treat<\/span><\/li>\n  <li><span class='match'>trust<\/span><\/li>\n  <li><span class='match'>window<\/span><\/li>\n  <li><span class='match'>yesterday<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice.)

```r
str_view(stringr::words, pattern = "(..).*\\1", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-669fca315631367fbaab" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-669fca315631367fbaab">{"x":{"html":"<ul>\n  <li>ap<span class='match'>propr<\/span>iate<\/li>\n  <li><span class='match'>church<\/span><\/li>\n  <li>c<span class='match'>ondition<\/span><\/li>\n  <li><span class='match'>decide<\/span><\/li>\n  <li><span class='match'>environmen<\/span>t<\/li>\n  <li>l<span class='match'>ondon<\/span><\/li>\n  <li>pa<span class='match'>ragra<\/span>ph<\/li>\n  <li>p<span class='match'>articular<\/span><\/li>\n  <li><span class='match'>photograph<\/span><\/li>\n  <li>p<span class='match'>repare<\/span><\/li>\n  <li>p<span class='match'>ressure<\/span><\/li>\n  <li>r<span class='match'>emem<\/span>ber<\/li>\n  <li><span class='match'>repre<\/span>sent<\/li>\n  <li><span class='match'>require<\/span><\/li>\n  <li><span class='match'>sense<\/span><\/li>\n  <li>the<span class='match'>refore<\/span><\/li>\n  <li>u<span class='match'>nderstand<\/span><\/li>\n  <li>w<span class='match'>hethe<\/span>r<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Contain one letter repeated in at least three places (e.g. “eleven” contains three “e”s.)

```r
str_view(stringr::words, pattern = "(.).*\\1.*\\1", match = TRUE)
```

<!--html_preserve--><div id="htmlwidget-6da34d5628755d61358b" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-6da34d5628755d61358b">{"x":{"html":"<ul>\n  <li>a<span class='match'>pprop<\/span>riate<\/li>\n  <li><span class='match'>availa<\/span>ble<\/li>\n  <li>b<span class='match'>elieve<\/span><\/li>\n  <li>b<span class='match'>etwee<\/span>n<\/li>\n  <li>bu<span class='match'>siness<\/span><\/li>\n  <li>d<span class='match'>egree<\/span><\/li>\n  <li>diff<span class='match'>erence<\/span><\/li>\n  <li>di<span class='match'>scuss<\/span><\/li>\n  <li><span class='match'>eleve<\/span>n<\/li>\n  <li>e<span class='match'>nvironmen<\/span>t<\/li>\n  <li><span class='match'>evidence<\/span><\/li>\n  <li><span class='match'>exercise<\/span><\/li>\n  <li><span class='match'>expense<\/span><\/li>\n  <li><span class='match'>experience<\/span><\/li>\n  <li><span class='match'>indivi<\/span>dual<\/li>\n  <li>p<span class='match'>aragra<\/span>ph<\/li>\n  <li>r<span class='match'>eceive<\/span><\/li>\n  <li>r<span class='match'>emembe<\/span>r<\/li>\n  <li>r<span class='match'>eprese<\/span>nt<\/li>\n  <li>t<span class='match'>elephone<\/span><\/li>\n  <li>th<span class='match'>erefore<\/span><\/li>\n  <li>t<span class='match'>omorro<\/span>w<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

### Exercises 14.4.2
#### Q1
For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple str_detect() calls.

Find all words that start or end with x.

```r
# single regular expression
str_subset(stringr::words, pattern = "^x|x$") %>% 
  knitr::kable(col.names = c("Single Regular Expression"))
```



|Single Regular Expression |
|:-------------------------|
|box                       |
|sex                       |
|six                       |
|tax                       |

```r
# multiple str_detect()
m1 <- str_detect(stringr::words, pattern = "^x")
m2 <- str_detect(stringr::words, pattern = "x$")

## show table
stringr::words %>% 
  `[`(m1 | m2) %>% 
  knitr::kable(col.names = c("Multiple str_detect()"))
```



|Multiple str_detect() |
|:---------------------|
|box                   |
|sex                   |
|six                   |
|tax                   |

Find all words that start with a vowel and end with a consonant.

```r
# single regular expression, here we just search first 10 rows
str_subset(stringr::words[1:10], pattern = "^[aeiou].*[^aeiou]$") %>% 
  knitr::kable(col.names = c("Single Regular Expression"))
```



|Single Regular Expression |
|:-------------------------|
|about                     |
|accept                    |
|account                   |
|across                    |
|act                       |

```r
# multiple str_detect(), here we just search first 10 rows
m1 <- str_detect(stringr::words[1:10], pattern = "^[aeiou].*")
m2 <- str_detect(stringr::words[1:10], pattern = "[^aeiou]$")

## show table
stringr::words[1:10] %>% 
  `[`(m1 & m2) %>% 
  knitr::kable(col.names = c("Multiple str_detect()"))
```



|Multiple str_detect() |
|:---------------------|
|about                 |
|accept                |
|account               |
|across                |
|act                   |

Are there any words that contain at least one of each different vowel?
Answer: In orer to use single regular expression, we need to wirte 5*4*3*2*1=120 conditions. For example, we need to match "abc"" disorderly. There are 6 conditions: abc, acd, bac, bca, cab, cba. It is therefore seems impossible to use a single regular expression to finish this question.
However, we could use "?=" which is a positive lookahead, a type of zero-width assertion to solve this problem.

```r
test_words <- c("eioua", "aaaaa", "abcde", "aeeiuuo", "eeeiuuuuo")

# single regular expression
str_subset(test_words, pattern = "(?=.*a.*)(?=.*e.*)(?=.*i.*)(?=.*o.*)(?=.*u.*)") %>% 
  knitr::kable(col.names = c("Single Regular Expression"))
```



|Single Regular Expression |
|:-------------------------|
|eioua                     |
|aeeiuuo                   |

```r
# multiple str_detect()
m1 <- str_detect(test_words, pattern = "(?=.*a.*)")
m2 <- str_detect(test_words, pattern = "(?=.*e.*)")
m3 <- str_detect(test_words, pattern = "(?=.*i.*)")
m4 <- str_detect(test_words, pattern = "(?=.*o.*)")
m5 <- str_detect(test_words, pattern = "(?=.*u.*)")

## show table
test_words %>% 
  `[`(m1 & m2 & m3 & m4 & m5) %>% 
  knitr::kable(col.names = c("Multiple str_detect()"))
```



|Multiple str_detect() |
|:---------------------|
|eioua                 |
|aeeiuuo               |

####Q2
What word has the highest number of vowels?

```r
# The highest number of vowels
max(str_count(stringr::words, "[aeiou]")) %>% 
  knitr::kable(col.names = c("Highest Number of Vowelss"))
```



| Highest Number of Vowelss|
|-------------------------:|
|                         5|

```r
# find the words with the highest number of vowels
num_vowels <- str_count(stringr::words, "[aeiou]")

stringr::words %>% 
  `[`(num_vowels == max(num_vowels)) %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|appropriate    |
|associate      |
|available      |
|colleague      |
|encourage      |
|experience     |
|individual     |
|television     |

What word has the highest proportion of vowels? (Hint: what is the denominator?)

```r
#  find highest proportion of vowels
portion_vowels <- str_count(stringr::words, "[aeiou]")/str_length(stringr::words)

stringr::words %>% 
  `[`(portion_vowels == max(portion_vowels)) %>% 
  knitr::kable(col.names = c("Detected Words"))
```



|Detected Words |
|:--------------|
|a              |

### Exercises 14.4.3.1



